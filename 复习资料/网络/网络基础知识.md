### 1、网络通信过程中的数据推送方式

**“推送”是一种业务行为，而 HTTP/WebSocket 是实现这种行为的工具。**

![alt text](/Java/网络/img/image.png)

#### （1）轮询 & 长轮询 (基于 HTTP 的妥协)

**短轮询 (Polling)：**
- 原理：客户端写个死循环，每秒发一个 HTTP 请求：“有数据吗？” Server：“没有”。Client：“有吗？” Server：“没有”。
- 关系：完全符合标准 HTTP 的“请求-响应”模型。
- 缺点：太笨了，浪费带宽。

**长轮询 (Long Polling)：**
- 原理：客户端发 HTTP 请求：“有数据吗？”
- 服务器的处理：服务器不立马返回！它拿着这个请求不放（Hold 住连接），一直等到有数据了，或者 30 秒超时了，才返回 Response。
- 关系：依然是 HTTP 协议，但改变了“立即返回”的习惯。
- 缺点：依然是 HTTP 请求，Header 开销大，且每次断开后还得重新发起请求。服务端可能 hold 住很多连接，导致服务端压力过大。

#### （2）SSE (Server-Sent Events) (HTTP 的流式能力)

- 原理：客户端发一个 HTTP 请求，Header 里带上 Accept: text/event-stream。服务器回一个 Response，状态码 200，Content-Type 也是 text/event-stream。

- 关键点：服务器不关闭这个 Response，而是利用 HTTP 的 Chunked Transfer Encoding（分块传输），源源不断地往回写数据（data: hello\n\n）。

- 关系：SSE 就是 HTTP。它没有新协议，只是利用了 HTTP 长连接和流式传输的特性。

- 特点：
    - 单向：只能服务器推给客户端，客户端不能推回去（除非发新请求）。
    - 轻量：比 WebSocket 简单，适合股票行情、日志推送。

#### （3）WebSocket (彻底的新协议)

这是为了解决 HTTP “请求-响应”模式无法双向通信而诞生的。

**原理：**
- 握手 (Handshake)：客户端先发一个 HTTP 请求，Header 里带 Upgrade: websocket。意思是：“大哥，HTTP 太慢了，我们要不要升级到 WebSocket？”。
- 升级：服务器如果支持，回 101 Switching Protocols。
- 脱胎换骨：此时，底层的 TCP 连接保持不变，但不再遵守 HTTP 协议了，而是开始遵守 WebSocket 协议（二进制帧格式）。
- 全双工：双方随时可以互发数据，不需要 Request/Response 的约束。

**关系：**
WebSocket 不是 HTTP。但是它借用了 HTTP 来完成“相亲”（握手）。一旦握手成功，它们就“领证结婚”了，之后过日子（传输数据）就跟 HTTP 没关系了，直接基于 TCP 跑。

#### 总结

**OSI 层级：**
- WebSocket / HTTP -> 应用层 (Layer 7)
- TCP -> 传输层 (Layer 4)
- IP -> 网络层 (Layer 3)

**数据流向：**
- HTTP (轮询/长轮询)：Client <---> Server (一问一答，哪怕答得很慢)
- HTTP (SSE)：Client <- Server (一问，然后一直答)
- WebSocket：Client <===> Server (互相随便说话，不需要问答)

### 2、不同版本的 HTTP 协议及其原理

#### HTTP/1.0 (短连接时代)
- 特点：引入了 Header、Status Code、Cache。
- 短连接 (Short Connection)：这是最大的痛点。每请求一个资源（比如网页里有 10 张图），都要经历 建立TCP -> 传输 -> 断开TCP。

#### HTTP/1.1 (长连接时代 - 依然坚挺)
**为了解决 1.0 连接复用问题而生。**

核心改进：
- 持久连接 (Keep-Alive)：默认开启。建立一次 TCP 连接后，不断开，可以连续发多个请求。
- 管道化 (Pipelining)：允许一次发多个请求，不用等回复（但服务器必须按顺序回，所以这个功能很鸡肋，浏览器默认都关闭）。
- Host 头：允许一台物理服务器部署多个网站（虚拟主机）。
- 断点续传：引入 Range 头，支持只请求文件的一部分。

致命缺陷：队头阻塞 (Head-of-Line Blocking)，因为 HTTP/1.1 规定响应必须按顺序返回。如果第一个请求处理很慢（比如查库 5秒），后面的请求即使处理完了，也得排队等着第一个发完才能发。

#### HTTP/2.0 (多路复用时代 - 性能飞跃)
**为了解决 1.1 的“队头阻塞”和“文本解析慢”而生。**

核心改进：
- **二进制分帧** (Binary Framing)：不再传输文本，而是把数据切成一个个二进制帧。机器解析更快。
- 多路复用 (Multiplexing)：在同一个 TCP 连接上，可以并发传输无数个 Stream（流）。每个请求都有唯一的 ID，乱序发送，乱序接收，最后根据 ID 组装。彻底解决了 HTTP 层面的队头阻塞。
- 头部压缩 (HPACK)：请求头压缩，不再重复传 User-Agent 等冗余信息。
- 服务器推送 (Server Push)：客户端请求 index.html，服务器主动把 style.css 也推给你。

**遗留痛点：**
HTTP/2 依然运行在 TCP 上。TCP 是可靠传输，TCP 层面的队头阻塞依然存在。如果网络丢了一个包，TCP 会暂停所有流的传输，直到那个包重传成功。这在网络环境差时，性能不如 HTTP/1.1。

#### HTTP/3.0 (QUIC 时代 - 颠覆底层)
**为了解决 TCP 的固有缺陷（握手慢、丢包阻塞）而生。**

**核心变革**：抛弃 TCP，改用 UDP。底层使用 Google 开发的 QUIC 协议 (Quick UDP Internet Connections)。

核心改进：
- 0-RTT 建连：因为 UDP 不需要握手，且 QUIC 缓存了加密参数，第二次连接时可以直接发数据。速度极快。

- 解决 TCP 队头阻塞：QUIC 的流（Stream）之间是完全独立的。Stream A 的包丢了，只影响 A，Stream B 继续传输，不受影响。

连接迁移 (Connection Migration)：
- 传统 TCP 靠 IP+端口 识别连接。你从 Wi-Fi 切到 4G，IP 变了，TCP 连接必断。
- QUIC 靠 Connection ID (CID) 识别。只要 CID 不变，网络切换了，连接依然保持，不需要重连。

### 3、重要协议的原理

- TCP协议与UDP协议的原理
- 三次握手四次挥手的原理
- HTTPs协议的原理
- WebSocket协议的原理
- QUIC 协议的原理
- 现在网站一般不会使用cookie和session来保持状态，那都用什么方式来保持状态（Token机制）








