## 1、设计一个秒杀系统

### 1、核心设计原则

设计秒杀系统，要遵从3个原则
- **高可用**：秒杀业务挂了，不能影响主站业务（比如普通的搜索、下单）。结论：服务隔离，数据库隔离。
- **高性能**：请求必须在到达数据库前被拦截，全链路低延迟。
- **强一致性**：绝对不能超卖（卖出 101 个商品），尽量也不能少卖。

### 2、架构设计（漏斗模型）

我们要像漏斗一样，把巨大的流量一层层拦在外面。

#### （1）客户端（App/H5）—— 视觉欺骗与拦截

- **按钮控制**：点击“立即抢购”后，按钮立刻置灰 5 秒。作用：拦住 90% 的手抖用户和重复点击。

- **静态资源 CDN**：秒杀页面的 CSS/JS/图片 全部推送到 CDN，不打后端服务器。

- **动态 URL**：不要写死 /seckill/sku_123，防止脚本提前刷接口。 URL 应该是动态获取的（见下文“防刷”）。

#### （2）接入层（Nginx/Gateway）—— 流量清洗
- **IP 限流**：限制单 IP 每秒请求数。

- **黑名单**：识别爬虫 User-Agent 或异常 IP，直接返回 403。

- **动静分离**：只放行 API 请求给后端，静态请求全部由 Nginx 挡回去。

#### （3）服务层

- **请求队列**：如果瞬间流量太大，可以引入内部队列或线程池排队，抛弃多余请求。

- **缓存层（Redis）—— 核心战场**：利用 Redis DECR 原子递减，或者 Lua 脚本。只有在 Redis 扣减成功的（stock >= 0），才有资格进入下一步。

- **消息队列（MQ）—— 削峰填谷**：通过 MQ 异步下单，抢到 Redis 库存的用户，不是立刻写数据库，而是发一条消息到 MQ（RabbitMQ/Kafka）。立即返回：告诉用户“排队中/抢购中”，前端启动轮询器（Polling）查询最终结果。

#### （4）数据库层

Consumer 消费 MQ，执行最终的 SQL 并生成订单，在 DB 插入订单记录。插入业务要进行幂等性验证，同一个用户不可以重复下单。

### 3、关键痛点解决方案

#### （1）如何解决“超卖”问题

在 Redis 缓存层，通过 lua 脚本将“判断库存”和“扣减库存”做成原子操作。

~~~ lua
if (redis.call('get', KEYS[1]) > 0) then
    redis.call('decr', KEYS[1]);
    return 1;
else
    return 0;
end
~~~

数据库兜底： 即使 Redis 扣成功了，DB 写入时也要加保险，创建订单时要判断库存大于0
~~~ java
UPDATE stock_table SET count = count - 1 WHERE id = 123 AND count > 0;
~~~

#### （2）如何防止“少卖”？ (库存长时间被占用但不支付)

场景：Redis 扣了库存，用户占了坑，结果 30 分钟不支付。

解法：库存回滚。用户订单超时未支付，执行订单到期关闭。订单超时关闭后，必须发消息给库存服务，把 Redis 的库存 INCR 加回去，并把 DB 库存加回去。

#### （3）如何防止脚本/机器人抢购

**数学验证码**：在抢购前弹出一个简单的数学题（12+8=?），防止简单脚本高频重放。

**隐藏秒杀地址，不要写死秒杀接口地址**：
- 秒杀开始前，按钮不可点。
- 点击按钮，先请求 /get_token 接口，服务器根据 UserID + 商品ID + 盐 算出一个随机 Token（MD5）。
- 真正的下单接口是 /seckill/verify_token/{token}。没有这个 Token，直接拒绝。

#### （4）Redis 挂了怎么办

- **主从/集群架构确保 Redis 高可用**：基本的 Redis 高可用。

- **本地缓存兜底**：如果 Redis 真的全挂了，Switch 降级，由应用层本地缓存直接拦截所有请求，虽然秒杀失败，但系统没挂（弃车保帅）。

### 4、面试问题

#### （1）面试官问“你讲讲秒杀系统的核心思路？”

回答话术： “秒杀系统的核心在于**流量削峰和读写分离**。

**架构上**：我采用漏斗模型。前端拦截 90% 请求，网关限流拦截 5% 请求，Redis 预扣库存处理核心流量，最后只有极少数请求（等于库存数）才会打到数据库。

**数据上**：利用 Redis 原子性（Lua 脚本）做库存预扣，利用 MQ 做异步下单，将突发的写流量转化为平滑的流式写入，保护后端数据库不被击穿。”

#### （2）面试官追问“如果 Redis 扣减成功，但 MQ 写数据库失败了怎么办（数据不一致）？”

回答话术： “这涉及分布式一致性。

- 本地消息表：在发送 MQ 前，先在本地库插一条‘消息发送记录’（事务内）。
- **MQ 可靠投递**：利用 MQ 的 confirm 机制保证消息发出。
- **消费端重试**：如果 DB 写失败，让 MQ 重试。
- **最终一致性**：如果实在写不进去（比如 DB 挂了），要有脚本进行对账。活动结束后，比对 Redis 扣减数量和 DB 订单数量，人工介入处理。 在秒杀场景下，我们优先保证不超卖，对于极个别的数据不一致，可以通过人工补偿解决。”

#### （3）面试官问“怎么解决一个用户用多个账号同时抢？”

回答话术： “这属于风控范畴。

- **限制设备/IP**：同一个设备指纹或同一个 IP，限制只能登陆 1 个账号。

- **业务限流**：在 Redis 里记录 userId_skuId，设置 nx（setIfAbsent），限制单用户对单商品只能请求一次。

- **风控服务**：接入阿里的风控或自研风控，基于历史行为识别僵尸号，直接在网关层拦截。”






















































































